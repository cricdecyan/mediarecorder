<!DOCTYPE html>
<html>
<head>
<title>MediaStream Recoder Manual Test (w/ MediaSource)</title>
</head>
<body>
  <div> Record Real-Time video test.</div>
  <video id="localVideo" autoplay></video>
  <video id="remoteVideo" autoplay></video>
  <br>GetUserMedia options</br>
  <label>Enable Audio</label>
  <select id="enable_audio">
    <option value="true">yes</option>
    <option value="false">no</option>
  </select>
  <label>Enable Video</label>
  <select id="enable_video">
    <option value="true">yes</option>
    <option value="false">no</option>
  </select>
  <label>Video resolution</label>
  <select id="resolution">
    <option value="">system default</option>
    <option value="160x120">160x120</option>
    <option value="320x240">320x240</option>
    <option value="640x480">640x480</option>
    <option value="1280x720">1280x720</option>
    <option value="1920x1080">1920x1080</option>
  </select>
  <br></br>
  <button onclick="getUserMedia();">GetUSerMedia</button>
  <button onclick="stopStream(theLocalStream);">StopLocalStream</button>
  <button onclick="stopStream(theLocalStream, 'video');">StopLocalVideoTrack
  </button>
  <button onclick="stopStream(theLocalStream, 'audio');">StopLocalAudioTracks
  </button>
  <button onclick="stopStream(theRemoteStream);">StopRemoteStream</button>
  <button onclick="stopStream(theRemoteStream, 'video');">StopRemoteVideoTrack
  </button>
  <button onclick="stopStream(theRemoteStream, 'audio');">StopRemoteAudioTracks
  </button>
  <br></br>
  <br>Remote Peer Connection</br>
  <button onclick="createPeerConnection();">CreatePeerConnection</button>
  <br></br>
  <br>Recorder Options</br>
  <label>Stream To Record</label>
  <select id="recorded_stream">
    <option value="remote">remote</option>
    <option value="local">local</option>
  </select>
  <label>Audio Codec</label>
  <select id="audio_codec">
    <option value="opus">opus</option>
  </select>
  <label>Audio BitRate</label>
  <select id="audio_bitrate">
    <option value="default">system default</option>
    <option value="96000">96kpbs</option>
    <option value="128000">128kbps</option>
    <option value="160000">160kbps</option>
    <option value="192000">192kbps</option>
    <option value="256000">256kbps</option>
    <option value="400000">400kbps</option>
  </select>
  <label>Video Codec</label>
  <select id="video_codec">
    <option value="default">system default</option>
    <option value="VP8">VP8</option>
    <option value="VP9">VP9</option>
  </select>
  <label>Video Bitrate</label>
  <select id="video_bitrate">
    <option value="default">system default</option>
    <option value="16000">16kpbs</option>
    <option value="128000">128kbps</option>
    <option value="160000">160kbps</option>
    <option value="192000">192kbps</option>
    <option value="256000">256kbps</option>
    <option value="384000">384kbps</option>
    <option value="400000">400kbps</option>
    <option value="750000">750kbps</option>
    <option value="1000000">1Mbps</option>
    <option value="2500000">2.5Mbps</option>
    <option value="3500000">3.5Mbps</option>
    <option value="6800000">6.8Mbps</option>
    <option value="9800000">9.8Mbps</option>
    <option value="15000000">15Mbps</option>
  </select>
  <label>Overall Bitrate</label>
  <select id="overall_av_bitrate">
    <option value=""></option>
    <option value="128000">128kbps</option>
    <option value="160000">160kbps</option>
    <option value="192000">192kbps</option>
    <option value="256000">256kbps</option>
    <option value="384000">384kbps</option>
    <option value="400000">400kbps</option>
    <option value="750000">750kbps</option>
    <option value="1000000">1Mbps</option>
    <option value="2500000">2.5Mbps</option>
    <option value="3500000">3.5Mbps</option>
    <option value="6800000">6.8Mbps</option>
    <option value="9800000">9.8Mbps</option>
    <option value="15000000">15Mbps</option>
  </select>
  <br>Time slice 
    <select id="timeslice">
      <option value=""></option>
      <option value="100">100ms</option>
      <option value="200">200ms</option>
      <option value="1000">1,000ms</option>
      <option value="10000">10,000ms</option>
      <option value="100000">100,000ms</option>
      <option value="1000000">1,000,000ms</option>
      <option value="1800000">30 min</option>
      <option value="3600000">1 hour</option>
      <option value="7200000">2 hours</option>
      <option value="86400000">24 hours</option>
    </select>
    <label>Ignore Muted Media</label>
    <select id="ignore_muted">
      <option value="no">no</option>
      <option value="yes">yes</option>
    </select>
    <br></br>
    <label> Monitor Recorder Event</label>
    <select id="monitor_events">
      <option value=""></option>
      <option value="all events">all events</option>
      <option value="onstart">onstart</option>
      <option value="onstop">onstop</option>
      <option value="ondataavailable">ondataavailable</option>
      <option value="onpause">onpause</option>
      <option value="onresume">onresume</option>
      <option value="onerror">onerror</option>
    </select>
  </br>
  <br></br>
  <br>Recorder Controls</br>
  <button onclick="startRecorder();">Start</button>
  <button onclick="pauseRecorder();">Pause</button>
  <button onclick="resumeRecorder();">Resume</button>
  <button onclick="stopRecorder();">Stop</button>
  <button onclick="requestData();">RequestData</button>
  <br></br>
  <br> Playback Controls</br>
  <video id="playbackVideo" autoplay></video>
  <br>
    <button onclick="playback();">Playback</button>
    <button onclick="download();">Download</button>
  </br>
  <br>Recorder State</br>
  <textarea id="recorder_state" readonly></textarea>
  <br>Recorder Events</br>
  <label>onstart</label>
  <textarea id="onstart_count" readonly></textarea>
  <label>onstop</label>
  <textarea id="onstop_count" readonly></textarea>
  <label>onpause</label>
  <textarea id="onpause_count" readonly></textarea>
  <label>onresume</label>
  <textarea id="onresume_count" readonly></textarea>
  <label>ondataavailable</label>
  <textarea id="ondataavailable_count" readonly></textarea>
  <label>onerror</label>
  <textarea id="onerror_count" readonly></textarea>




</body>
<script>

'use strict';
var theLocalStream = null;
var theRemoteStream = null;

function getSelectedValue(id) {
  var e = document.getElementById(id);
  return e.options[e.selectedIndex].value;
} 

function buildConstraints(audioEnabled, videoEnabled, resolution) {
  var constraints = {audio:false, video:false};
  var res = resolution.split('x');
  var width = res[0];
  var height = res[1];
  if (height && videoEnabled) {
    constraints.video = {mandatory: {
      minWidth: width,
      minHeight: height,
      maxWidth: width,
      maxHeight: height
    }};
  } else if (videoEnabled) {
    constraints.video = true
  }

  if (audioEnabled) {
    constraints.audio = true;
  }
  return constraints;
}

function isTrue(str) {
 if (str == 'true') {
   return true;
 } else {
   return false; 
 }
}

function getUserMedia() {
 var enableAudio = isTrue(getSelectedValue('enable_audio'));
 var enableVideo = isTrue(getSelectedValue('enable_video'));
 var resolution = getSelectedValue('resolution');
 var constraints = buildConstraints(enableAudio, enableVideo, resolution);

 navigator.mediaDevices.getUserMedia(constraints)
    .then(function(stream) {
      document.getElementById('localVideo').src = URL.createObjectURL(stream);
      theLocalStream = stream;
    });
}

function stopStream(stream, tracksType) {
  return new Promise(function(resolve, reject) {
    var tracks = null;
    if (!stream)
      reject('Stream is not initialized!');
    if (tracksType == 'video') {
      tracks = stream.getVideoTracks();
    } else if (tracksType == 'audio') {
      tracks = stream.getAudioTracks();
    } else {
      tracks = stream.getTracks();
    }
    tracks.forEach(function(track) {
        track.stop();
    });
    resolve();
  });
}

// This test must be run with experimental GetUserMedia flag on.

var testProgress = 0;
var result;

function failTest(reason) {
  result = 'FAIL: ' + reason;
  console.log('Test Failed:', reason);
  testProgress = 1;
  // Cause test termination.
  throw reason;
}

function reportTestSuccess() {
  result = 'PASS';
  console.log('Test Passed');
  testProgress = 1;
}

function assertEquals(expected, actual) {
  if (actual != expected)
    failTest("expected '" + expected + "', got '" + actual + "'.");
}

function assertTrue(booleanExpression, reason) {
  if (!booleanExpression)
    failTest(reason);
}

// End cros related code.

const DEFAULT_CONSTRAINTS = {audio: true, video: true};
const DEFAULT_RECORDER_MIME_TYPE = '';
const DEFAULT_TIME_SLICE = 100;
const FREQUENCY = 880;
// Note that not all audio sampling rates are supported by the underlying
// Opus audio codec: the valid rates are 8kHz, 12kHz, 16kHz, 24kHz, 48kHz.
// See crbug/569089 for details.
const SAMPLING_RATE = 48000;
const NUM_SAMPLES = 2 * SAMPLING_RATE;

// Function assert_throws inspired from Blink's
// LayoutTests/resources/testharness.js

function assertThrows(func, description) {
  try {
    func.call(this);
    failTest('Error:' + func + description + ' did not throw!');
  } catch (e) {
    console.log(e);
    reportTestSuccess();
  }
}

function createPeerConnection(stream) {
  setupPeerConnection(theLocalStream)
      .then(function(stream) {
        theRemoteStream = stream;
      });
}

function setupPeerConnection(stream) {
  return new Promise(function(resolve, reject) {
    var localStream = stream;
    var remoteStream = null;
    var localPeerConnection = new webkitRTCPeerConnection(null);
    var remotePeerConnection = new webkitRTCPeerConnection(null);

    function createAnswer(description) {
      remotePeerConnection.createAnswer(function(description) {
        remotePeerConnection.setLocalDescription(description);
        localPeerConnection.setRemoteDescription(description);
      });
    }

    if (!localStream)
      reject('Stream not initialized!!');

    localPeerConnection.onicecandidate = function(event) {
      if (event.candidate) {
        remotePeerConnection.addIceCandidate(new RTCIceCandidate(
            event.candidate));
      }
    };
    remotePeerConnection.onicecandidate = function(event) {
      if (event.candidate) {
        localPeerConnection.addIceCandidate(new RTCIceCandidate(
            event.candidate));
      }
    };
    remotePeerConnection.onaddstream = function(event) {
      document.getElementById("remoteVideo").src = URL.createObjectURL(
          event.stream);
      remoteStream = event.stream;
      resolve(remoteStream);
    };

    localPeerConnection.addStream(localStream);

    localPeerConnection.createOffer(function(description) {
      localPeerConnection.setLocalDescription(description);
      remotePeerConnection.setRemoteDescription(description);
      createAnswer(description);
    });
  });
}

function createAndStartMediaRecorder(stream, mimeType, slice) {
  return new Promise(function(resolve, reject) {
    document.getElementById('video').src = URL.createObjectURL(stream);
    var recorder = new MediaRecorder(stream, {'mimeType' : mimeType});
    console.log('Recorder object created.');
    if (slice != undefined) {
      recorder.start(slice);
      console.log('Recorder started with time slice', slice);
    } else {
      recorder.start();
    }
    resolve(recorder);
  });
}

function createMediaRecorder(stream, mimeType) {
  return new Promise(function(resolve, reject) {
    var recorder = new MediaRecorder(stream, {'mimeType' : mimeType});
    console.log('Recorder object created.');
    resolve(recorder);
  });
}

// Tests that the MediaRecorder's start() function will cause the |state| to be
// 'recording' and that a 'start' event is fired.
function testStartAndRecorderState() {
  var startEventReceived = false;
  navigator.mediaDevices.getUserMedia(DEFAULT_CONSTRAINTS)
      .then(function(stream) {
        return createMediaRecorder(stream, DEFAULT_RECORDER_MIME_TYPE);
      })
      .then(function(recorder) {
        recorder = recorder;
        recorder.onstart = function(event) {
          startEventReceived = true;
          assertEquals('recording', recorder.state);
        };
        recorder.start();
      })
      .then(function() {
        return waitFor('Make sure the start event was received',
            function() {
              return startEventReceived;
            });
      })
      .catch(function(err) {
        return failTest(err.toString());
      })
      .then(function() {
        reportTestSuccess();
      });
}

// Tests that the MediaRecorder's stop() function will effectively cause the
// |state| to be 'inactive' and that a 'stop' event is fired.
function testStartStopAndRecorderState() {
  var stopEventReceived = false;
  navigator.mediaDevices.getUserMedia(DEFAULT_CONSTRAINTS)
      .then(function(stream) {
        return createAndStartMediaRecorder(stream, DEFAULT_RECORDER_MIME_TYPE);
      })
      .then(function(recorder) {
        recorder.onstop = function(event) {
          stopEventReceived = true;
          assertEquals('inactive', recorder.state);
        };
        recorder.stop();
      })
      .then(function() {
        return waitFor('Make sure the stop event was received',
            function() {
              return stopEventReceived;
            });
      })
      .catch(function(err) {
        return failTest(err.toString());
      })
      .then(function() {
        reportTestSuccess();
      });
}

// Tests that when MediaRecorder's start() function is called, some data is
// made available by media recorder via dataavailable events, containing non
// empty blob data.
function testStartAndDataAvailable() {
  var videoSize = 0;
  var emptyBlobs = 0;
  var timeStamps = [];
  navigator.mediaDevices.getUserMedia(DEFAULT_CONSTRAINTS)
      .then(function(stream) {
        return createAndStartMediaRecorder(stream, DEFAULT_RECORDER_MIME_TYPE);
      })
      .then(function(recorder) {
        // Save history of Blobs received via dataavailable.
        recorder.ondataavailable = function(event) {
          timeStamps.push(event.timeStamp);
          if (event.data.size > 0)
            videoSize += event.data.size;
          else
            emptyBlobs += 1;
        };
      })
      .then(function() {
        return waitFor('Make sure the recording has data',
            function() {
              return videoSize > 0;
            });
      })
      .then(function() {
        assertTrue(emptyBlobs == 0, 'Recording has ' + emptyBlobs +
            ' empty blobs, there should be no such empty blobs.');
      })
      .catch(function(err) {
        return failTest(err.toString());
      })
      .then(function() {
        reportTestSuccess();
      });
}

// Tests that when MediaRecorder's start(timeSlice) is called, some data
// available events are fired containing non empty blob data.
function testStartWithTimeSlice() {
  var videoSize = 0;
  var emptyBlobs = 0;
  var timeStamps = [];
  navigator.mediaDevices.getUserMedia(DEFAULT_CONSTRAINTS)
      .then(function(stream) {
        return createAndStartMediaRecorder(stream, DEFAULT_RECORDER_MIME_TYPE,
            DEFAULT_TIME_SLICE);
      })
      .then(function(recorder) {
        recorder.ondataavailable = function(event) {
          timeStamps.push(event.timeStamp);
          if (event.data.size > 0)
            videoSize += event.data.size;
          else
            emptyBlobs += 1;
        };
      })
      .then(function() {
        return waitFor('Making sure the recording has data',
            function() {
              return videoSize > 0 && timeStamps.length > 10;
            });
      })
      .then(function() {
        assertTrue(emptyBlobs == 0, 'Recording has ' + emptyBlobs +
            ' empty blobs, there should be no such empty blobs.');
      })
      .catch(function(err) {
        return failTest(err.toString());
      })
      .then(function() {
        reportTestSuccess();
      });
}


// Tests that when a MediaRecorder's resume() is called, the |state| is
// 'recording' and a 'resume' event is fired.
function testResumeAndRecorderState() {
  var theRecorder;
  var resumeEventReceived = false;
  navigator.mediaDevices.getUserMedia(DEFAULT_CONSTRAINTS)
      .then(function(stream) {
        return createAndStartMediaRecorder(stream, DEFAULT_RECORDER_MIME_TYPE);
      })
      .then(function(recorder) {
        theRecorder = recorder;
        theRecorder.pause();
      })
      .then(function() {
        theRecorder.onresume = function(event) {
          resumeEventReceived = true;
          assertEquals('recording', theRecorder.state);
        };
        theRecorder.resume();
      })
      .then(function() {
        return waitFor('Making sure the resume event has been received',
            function() {
              return resumeEventReceived;
            });
      })
      .catch(function(err) {
        return failTest(err.toString());
      })
      .then(function() {
        reportTestSuccess();
      });
}

// Tests that is it not possible to resume an inactive MediaRecorder.
function testIllegalResumeThrowsDOMError() {
  navigator.mediaDevices.getUserMedia(DEFAULT_CONSTRAINTS)
      .then(function(stream) {
        return createMediaRecorder(stream, DEFAULT_RECORDER_MIME_TYPE);
      })
      .then(function(recorder) {
        assertThrows(function() {recorder.resume()}, 'Calling resume() in' +
            ' inactive state should cause a DOM error');
      });
}

// Tests that MediaRecorder sends data blobs when resume() is called.
function testResumeAndDataAvailable() {
  var videoSize = 0;
  var emptyBlobs = 0;
  navigator.mediaDevices.getUserMedia(DEFAULT_CONSTRAINTS)
      .then(function(stream) {
        return createAndStartMediaRecorder(stream, DEFAULT_RECORDER_MIME_TYPE);
      })
      .then(function(recorder) {
        recorder.pause();
        recorder.ondataavailable = function(event) {
          if (event.data.size > 0) {
            videoSize += event.data.size;
          } else {
            console.log('This dataavailable event is empty', event);
            emptyBlobs += 1;
          }
        };
        recorder.resume();
      })
      .then(function() {
        return waitFor('Make sure the recording has data after resuming',
            function() {
              return videoSize > 0;
            });
      })
      .then(function() {
        // There should be no empty blob while recording.
        assertTrue(emptyBlobs == 0, 'Recording has ' + emptyBlobs +
            ' empty blobs, there should be no such empty blobs.');
      })
      .catch(function(err) {
        return failTest(err.toString());
      })
      .then(function() {
        reportTestSuccess();
      });
}

// Tests that when paused the recorder will transition |state| to |paused| and
// then trigger a |pause| event.
function testPauseAndRecorderState() {
  var pauseEventReceived = false;
  navigator.mediaDevices.getUserMedia(DEFAULT_CONSTRAINTS)
      .then(function(stream) {
        return createAndStartMediaRecorder(stream, DEFAULT_RECORDER_MIME_TYPE);
      })
      .then(function(recorder) {
        recorder.onpause = function(event) {
          pauseEventReceived = true;
          assertEquals('paused', recorder.state);
        };
        recorder.pause();
      })
      .then(function() {
        return waitFor('Making sure the pause event has been received',
            function() {
              return pauseEventReceived;
            });
      })
      .catch(function(err) {
        return failTest(err.toString());
      })
      .then(function() {
        reportTestSuccess();
      });
}

// Tests that is is possible to stop a paused MediaRecorder and that the |state|
// becomes 'inactive'.
function testPauseStopAndRecorderState() {
  navigator.mediaDevices.getUserMedia(DEFAULT_CONSTRAINTS)
      .then(function(stream) {
        return createAndStartMediaRecorder(stream, DEFAULT_RECORDER_MIME_TYPE);
      })
      .then(function(recorder) {
        recorder.pause();
        recorder.stop();
        assertEquals('inactive', recorder.state);
      })
      .catch(function(err) {
        return failTest(err.toString());
      })
      .then(function() {
        reportTestSuccess();
      });
}

// Tests that no dataavailable event is fired after MediaRecorder's pause()
// function is called.
function testPausePreventsDataavailableFromBeingFired() {
  navigator.mediaDevices.getUserMedia(DEFAULT_CONSTRAINTS)
      .then(function(stream) {
        return createAndStartMediaRecorder(stream, DEFAULT_RECORDER_MIME_TYPE);
      })
      .then(function(recorder) {
        recorder.pause();
        recorder.ondataavailable = function(event) {
          failTest('Received unexpected data after pause!');
        };
      })
      .then(function() {
        return waitDuration(2000);
      })
      .catch(function(err) {
        return failTest(err.toString());
      })
      .then(function() {
        reportTestSuccess();
      });
}

// Tests that MediaRecorder's pause() throws an exception if |state| is not
// 'recording'.
function testIllegalPauseThrowsDOMError() {
  navigator.mediaDevices.getUserMedia(DEFAULT_CONSTRAINTS)
      .then(function(stream) {
        return createMediaRecorder(stream, DEFAULT_RECORDER_MIME_TYPE);
      })
      .then(function(recorder) {
        assertThrows(function() {recorder.pause()}, 'Calling pause() in' +
            ' inactive state should cause a DOM error');
      });
}

// Tests that a remote peer connection stream can be successfully recorded.
function testRecordRemotePeerConnection() {
  var videoSize = 0;
  var timeStamps = [];
  navigator.mediaDevices.getUserMedia(DEFAULT_CONSTRAINTS)
      .then(function(localStream) {
        return setupPeerConnection(localStream);
      })
      .then(function(remoteStream) {
        return createMediaRecorder(remoteStream, DEFAULT_RECORDER_MIME_TYPE);
      })
      .then(function(recorder) {
        recorder.ondataavailable = function(event) {
          timeStamps.push(event.timeStamp);
          videoSize += event.data.size;
        };
        recorder.start();
      })
      .then(function() {
        return waitFor('Making sure the recording has data',
            function() {
              return videoSize > 0 && timeStamps.length > 100;
            });
      })
      .catch(function(err) {
        return failTest(err.toString());
      })
      .then(function() {
        reportTestSuccess();
      });
}

// Tests that MediaRecorder's stop() throws an exception if |state| is not
// 'recording'.
function testIllegalStopThrowsDOMError() {
  navigator.mediaDevices.getUserMedia(DEFAULT_CONSTRAINTS)
      .then(function(stream) {
        return createMediaRecorder(stream, DEFAULT_RECORDER_MIME_TYPE);
      })
      .then(function(recorder) {
        assertThrows(function() {recorder.stop()}, 'Calling stop() in' +
            ' inactive state should cause a DOM error');
      });
}

// Tests that MediaRecorder's start() throws an exception if |state| is
// 'recording'.
function testIllegalStartInRecordingStateThrowsDOMError() {
  navigator.mediaDevices.getUserMedia(DEFAULT_CONSTRAINTS)
      .then(function(stream) {
        return createAndStartMediaRecorder(stream, DEFAULT_RECORDER_MIME_TYPE);
      })
      .then(function(recorder) {
        assertThrows(function() {recorder.start()}, 'Calling start() in' +
            ' recording state should cause a DOM error');
      });
}

// Tests that MediaRecorder's start() throws an exception if |state| is
// 'paused'.
function testIllegalStartInPausedStateThrowsDOMError() {
  navigator.mediaDevices.getUserMedia(DEFAULT_CONSTRAINTS)
      .then(function(stream) {
        return createAndStartMediaRecorder(stream, DEFAULT_RECORDER_MIME_TYPE);
      })
      .then(function(recorder) {
        recorder.pause();
        assertThrows(function() {recorder.start()}, 'Calling start() in' +
            ' paused state should cause a DOM error');
      });
}

// Tests that MediaRecorder can record a 2 Channel audio stream.
function testTwoChannelAudio() {
  var audioSize = 0;
  var context = new OfflineAudioContext(2, NUM_SAMPLES, SAMPLING_RATE);
  var oscillator = context.createOscillator();
  oscillator.type = 'sine';
  oscillator.frequency.value = FREQUENCY;
  var dest = context.createMediaStreamDestination();
  dest.channelCount = 2;
  oscillator.connect(dest);
  createMediaRecorder(dest.stream, DEFAULT_RECORDER_MIME_TYPE)
      .then(function(recorder) {
        recorder.ondataavailable = function(event) {
          audioSize += event.data.size;
        };
        recorder.start();
        oscillator.start();
        context.startRendering();
      })
      .then(function() {
        return waitFor('Make sure the recording has data',
            function() {
              return audioSize > 0;
            });
      })
      .catch(function(err) {
        return failTest(err.toString());
      })
      .then(function() {
        console.log('audioSize', audioSize);
        reportTestSuccess();
      });
}

// Tests that MediaRecorder's requestData() throws an exception if |state| is
// 'inactive'.
function testIllegalRequestDataThrowsDOMError() {
  navigator.mediaDevices.getUserMedia(DEFAULT_CONSTRAINTS)
      .then(function(stream) {
        return createMediaRecorder(stream, DEFAULT_RECORDER_MIME_TYPE);
      })
      .then(function(recorder) {
        assertThrows(function() {recorder.requestData()},
            'Calling requestdata() in inactive state should throw a DOM ' +
            'Exception');
      });
}

// Tests that MediaRecorder fires an Error Event when the associated MediaStream
// gets a Track added.
function testAddingTrackToMediaStreamFiresErrorEvent() {
  var localStream;
  var errorEventReceived = false;
  navigator.mediaDevices.getUserMedia(DEFAULT_CONSTRAINTS)
      .then(function(stream) {
        localStream = stream;
        return createMediaRecorder(stream);
      })
      .then(function(recorder) {
        recorder.onerror = function(event) {
          errorEventReceived = true;
        };
        recorder.start();
        // Add a new track, copy of an existing one for simplicity.
        localStream.addTrack(localStream.getTracks()[1].clone());
      })
      .then(function() {
        return waitFor('Waiting for the Error Event',
            function() {
              return errorEventReceived;
            });
      })
      .catch(function(err) {
        return failTest(err.toString());
      })
      .then(function() {
        reportTestSuccess();
      });
}

// Tests that MediaRecorder fires an Error Event when the associated MediaStream
// gets a Track removed.
function testRemovingTrackFromMediaStreamFiresErrorEvent() {
  var localStream;
  var errorEventReceived = false;
  navigator.mediaDevices.getUserMedia(DEFAULT_CONSTRAINTS)
      .then(function(stream) {
        localStream = stream;
        return createMediaRecorder(stream);
      })
      .then(function(recorder) {
        recorder.onerror = function(event) {
          errorEventReceived = true;
        };
        recorder.start();
        localStream.removeTrack(localStream.getTracks()[1]);
      })
      .then(function() {
        return waitFor('Waiting for the Error Event',
            function() {
              return errorEventReceived;
            });
      })
      .catch(function(err) {
        return failTest(err.toString());
      })
      .then(function() {
        reportTestSuccess();
      });
}

</script>
</body>
</html>
